test

import os
import csv
import json
import numpy as np
import faiss
from flask import Flask, render_template, request, jsonify, redirect, url_for
from sentence_transformers import SentenceTransformer

# Uncomment below to enable OpenAI GPT-4 Calls
import openai

# --------------------------------------------------------------------
# Check and Download AllMiniLM-L6-v2 Model
# --------------------------------------------------------------------
MODEL_PATH = "model_repo/all-MiniLM-L6-v2"
MODEL_NAME = "sentence-transformers/all-MiniLM-L6-v2"

def download_model_if_needed():
    """Checks if model exists; if not, downloads it."""
    if not os.path.exists(MODEL_PATH):
        print("üîπ Model not found. Downloading AllMiniLM-L6-v2...")
        model = SentenceTransformer(MODEL_NAME)
        model.save(MODEL_PATH)
        print("‚úÖ Model downloaded and saved at:", MODEL_PATH)
    else:
        print("‚úÖ Model already present. Loading from", MODEL_PATH)

download_model_if_needed()
embedding_model = SentenceTransformer(MODEL_PATH)
EMBEDDING_DIM = embedding_model.get_sentence_embedding_dimension()

app = Flask(__name__)

# --------------------------------------------------------------------
# GLOBAL VARIABLES
# --------------------------------------------------------------------
EVENT_INDEX = None
EVENT_EMBEDDINGS = None
EVENTS_DATA = []

# --------------------------------------------------------------------
# FAISS Vector Search Setup (Events)
# --------------------------------------------------------------------
def build_faiss_index_for_events(csv_path):
    """
    Loads events from CSV, generates embeddings using AllMiniLM-L6-v2,
    builds a FAISS index, and stores them in global variables.
    """
    global EVENT_INDEX, EVENT_EMBEDDINGS, EVENTS_DATA
    events = []
    try:
        with open(csv_path, newline='', encoding="utf-8") as f:
            reader = csv.DictReader(f)
            for row in reader:
                events.append(row)
    except Exception as e:
        print("‚ùå Error loading event data:", e)
        return

    if not events:
        print("‚ùå No events found in CSV.")
        return

    # Create text embeddings
    texts = [" ".join([e.get("Title", ""), e.get("Description", ""), e.get("Commodity", "")]) for e in events]
    embeddings = embedding_model.encode(texts, convert_to_numpy=True)

    # Build FAISS index
    index = faiss.IndexFlatL2(EMBEDDING_DIM)
    index.add(embeddings)

    EVENT_INDEX = index
    EVENT_EMBEDDINGS = embeddings
    EVENTS_DATA = events

def faiss_search_events(query_text, top_k=10):
    """Searches the FAISS index for matching events."""
    if EVENT_INDEX is None:
        print("‚ùå FAISS index not built.")
        return []
    query_emb = embedding_model.encode([query_text], convert_to_numpy=True)
    distances, indices = EVENT_INDEX.search(query_emb, top_k)
    return [EVENTS_DATA[idx] for idx in indices[0] if idx < len(EVENTS_DATA)]

# --------------------------------------------------------------------
# GPT-4 AI Insight Function
# --------------------------------------------------------------------
def call_gpt4_for_events(events_chunk, form_data):
    """
    Calls GPT-4 with event details and user input for AI insights.
    Ensures responses remain within token limits by chunking appropriately.
    """
    prompt = f"""
    You are an AI procurement assistant. Based on the following events and user input, provide:
    1. Score
    2. Reason
    3. Explanation
    4. Match Score
    5. Region
    6. Risks
    7. AI insights (trends, optimizations)

    Events: {events_chunk}
    Buyer Input: {form_data}

    Respond in JSON format.
    """

    response = openai.ChatCompletion.create(
        model='gpt-4',
        messages=[{"role": "system", "content": "You are a procurement AI assistant."},
                  {"role": "user", "content": prompt}],
        max_tokens=2000
    )
    # Parse JSON
    return json.loads(response['choices'][0]['message']['content'])

# --------------------------------------------------------------------
# Flask Routing
# --------------------------------------------------------------------
@app.before_request
def initialize_indices():
    """Loads FAISS index for events before first request."""
    csv_path = os.path.join("data", "small_tender_system_event_data.csv")
    build_faiss_index_for_events(csv_path)

@app.route("/")
def index():
    """Home Page"""
    return render_template("index.html")

@app.route("/generate_project", methods=["POST"])
def generate_project():
    """
    Handles event AI insights and ranking based on OpenAI GPT-4.
    """
    form_data = request.form.to_dict()
    commodity = form_data.get("commodity", "").strip()
    matched_events = faiss_search_events(commodity, top_k=50)

    # Ensure events are processed once
    event_data_json = json.dumps(matched_events[:5])  # Send first 5 for demonstration

    ai_insights = call_gpt4_for_events(event_data_json, form_data)

    # Merge AI insights with event data
    for i, evt in enumerate(matched_events[:5]):
        evt["ai_data"] = ai_insights["ranked_events"][i]

    # Sort events by AI score
    matched_events.sort(key=lambda x: x["ai_data"]["score"], reverse=True)

    return render_template("compareEvents.html", events=matched_events, form_data=form_data)

@app.route("/event_details/<event_id>")
def event_details(event_id):
    """Displays event details page."""
    event = next((e for e in EVENTS_DATA if e.get("EventID") == event_id), None)
    return render_template("event_details.html", event=event)

@app.route("/quotation_ai/<event_id>")
def quotation_ai(event_id):
    """Displays AI-based quotation analysis before comparing quotes."""
    return render_template("quotation_ai.html", event_id=event_id)

@app.route("/compare_quotes/<event_id>")
def compare_quotes(event_id):
    """Displays supplier AI comparison for a specific event."""
    return render_template("compare_quotes.html", event_id=event_id)

@app.route("/award", methods=["POST"])
def award():
    """Handles supplier award processing."""
    selected_suppliers = request.form.getlist("selected_suppliers")
    return render_template("award_result.html", awarded_suppliers=selected_suppliers)

if __name__ == "__main__":
    app.run(debug=True)
